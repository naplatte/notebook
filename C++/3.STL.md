### String 

#### ①几种构造函数重载

```cpp
string str1;// 默认构造函数
string str2 = "hello";//// 使用字符串字面值初始化
string str3(str2);// 拷贝构造
string str4(str2,1,4);// 使用部分初始化
string str5(5,'2');// 使用字符串字面值初始化
```

#### ②输出

- String类对象可以直接cout（标准库将<<重载了）
- stl其他容器则不能

```cpp
cout << str1;
```

#### ③读取输入的字符串

- 读取至第一个空格处

```cpp
std::string input;
std::cout << "请输入一个字符串：";
std::cin >> input; // 读取直到第一个空白字符
std::cout << "您输入的字符串是：" << input << std::endl;
```

- 读取包含空格的**整行字符串**
  - `getline()`：**按行读取输入**，直到遇到换行符为止（并把换行符丢掉）

```cpp
std::string line;
std::cout << "请输入一行文本：";
std::getline(std::cin, line);
std::cout << "您输入的文本是：" << line << std::endl;
return 0;
```

#### ④字符串操作

| 操作           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| os<<s          | 将 s 写到输出流 os 当中，返回 os，**os通常为输出流对象**     |
| is>>s          | 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is，**is通常为输入流对象** |
| getline(is, s) | 从 is 中读取一行赋给 s，返回 is                              |
| s.empty()      | s 为空返回 true，否则返回 false                              |
| s.size()       | 返回 s 中字符的个数                                          |
| s[n]           | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起                 |
| s1+s2          | 返回 s1 和 s2 连接后的结果                                   |
| s1=s2          | 用 s2 的副本代替 s1 中原来的字符                             |
| s1==s2         | 如果 s1 和 s2 中所含的字符完全一样，则它们相等；string 对象的相等性判断对字母的大小写敏感 |
| s1!=s2         | 与 `==` 相反，判断 s1 和 s2 是否不相等，对字母的大小写敏感   |
| <, <=, >, >=   | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感         |

#### ⑤比较运算符

- 长度相同，**逐个位置按字符比较**（比较字符的ASCII码大小）
- 长度不同，逐个位置按字符比较，若短字符串直至结尾每个字符都相同，则判定短字符串 < 长字符串

```cpp
"apple" > "appla";//e>a结束比较
"apple" > "applad";//e>a提前结束比较
"apple" < "appl"//直至短串结尾都相同，短串<长串
```

#### ⑥查找与替换

- `find`：查找一个子串/字符在原字符串中的位置（下标）

```cpp
size_t find(const std::string& str, size_t pos = 0) const;//默认是从下标为0开始查找
size_t find(const char* s, size_t pos = 0) const;
size_t find(char c, size_t pos = 0) const;
```

```cpp
string s1 = "hello";
string s2 = "llo";
int pos = s1.find(s2);
int pos1 = s1.find("ello");
int pos2 = s1.find('l');
int pos3 = s1.find('h',1);
cout << pos3;//-1,因为是从下标为1开始查找，找不到h
```

> -1和string::npos的关系
>
> - find找不到对应下标时，会返回string::npos，如果用size_t接收，即size_t pos = s1.find(s2)，此时pos会是一个很大的数，即无符号数各位全为1，如果用int接收，则会返回-1（补码）

- `replace(pos,n,str)`

```cpp
string text = "I love you";
string from = "you";
string to = "me";

size_t pos = text.find("you");
if (pos != string::npos) {
    text.replace(pos,from.length(),to);//从哪开始，持续几个字符，换成什么内容
}
cout << text;//I love me
```

#### ⑦子串与切片

- `substr(pos,n)`，输出从pos开始，长度为n的子串
- `substr(pos)`，输出从pos至结尾的子串

```cpp
auto str = text.substr(2);
cout << str;
```

#### ⑧常用字符操作

| 函数        | 功能                                                         |
| ----------- | ------------------------------------------------------------ |
| isalnum(c)  | 当 c 是字母或数字时为真                                      |
| isalpha(c)  | 当 c 是字母时为真                                            |
| iscntrl(c)  | 当 c 是控制字符时为真                                        |
| isdigit(c)  | 当 c 是数字时为真                                            |
| isgraph(c)  | 当 c 不是空格但可打印时为真                                  |
| islower(c)  | 当 c 是小写字母时为真                                        |
| isprint(c)  | 当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式）      |
| ispunct(c)  | 当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种） |
| isspace(c)  | 当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） |
| isupper(c)  | 当 c 是大写字母时为真                                        |
| isxdigit(c) | 当 c 是十六进制数字时为真                                    |
| tolower(c)  | 如果 c 是大写字母，输出对应的小写字母；否则原样输出 c        |
| toupper(c)  | 如果 c 是小写字母，输出对应的大写字母；否则原样输出 c        |

```cpp
// 其他有用的函数
str.clear(); // 清空字符串内容
str.erase(5, 7); // 从位置5开始，删除7个字符
str.insert(5, ","); // 在指定位置插入字符串或字符
str.find_first_of(); // 查找第一个匹配的字符
str.find_last_of(); // 查找最后一个匹配的字符

string s = "hello world";

size_t pos1 = s.find_first_of("aeiou"); // 查找最后一个元音字母(1)
size_t pos2 = s.find_last_of("abcde");   // 查找最后一个属于 "abcde" 的字符(10) - 字符串s中，最后一个匹配abcde任意一个字符的字符的下标
```

#### ⑨字符串流stringstream⭐

- `std::stringstream`是`<sstream>`提供的一个类，用于**在内存中进行字符串读写操作**，可以将字符串当做“流”一样来读写
- 像cout一样写入数据

```cpp
ss << "hello" << 123 << "world";

string s = ss.str(); // 取字符串
cout << s << endl;
```

- 像cin一样读入数据

```cpp
int a, b, c;
stringstream sss("100 200 300");
sss >> a >> b >> c; //类比cin >> a >> b >> c，将想输入的数据输入给变量
cout << a << "," << b << "," << c;
```

- **字符串分词**
  - 使用cin，原理相同，也可以得到分词
  - **cin**：数据来源是 **用户输入**，而**stringstream**数据来源是 **字符串**（程序内部已有的一整段文本）

```cpp
string line = "apple orange banana";
string word;

stringstream ss(line);

while (ss >> word) { // 类似 while (cin >> input) 因为 >> 遇到空白符（空格、换行、制表符）就停止读取
    cout << word << endl;
}

return 0;
```

#### ⑩类型转换

- `std::to_string()` 转为字符串
- `std::stoi()`，`std::stod()` 转为int ，double

- `string str(cstr)`  string提供的构造函数 将C风格转为字符串
- `c_str()` 将字符串转为C风格

#### ⑩①正则表达式

| 类 / 函数            | 用途                           |
| -------------------- | ------------------------------ |
| `std::regex`         | 定义一个正则表达式             |
| `std::smatch`        | 存放匹配结果（针对 string）    |
| `std::regex_match`   | 判断整个字符串是否匹配正则     |
| `std::regex_search`  | 判断字符串中是否存在匹配的子串 |
| `std::regex_replace` | 用正则替换字符串中的匹配内容   |

- 判断一个字符串是否匹配正则表达式`regex_match(待匹配的str,正则表达式)`

```cpp
string text = "hello world";
regex pattern("hello.*");
// 使用 std::regex_match 进行匹配
if (std::regex_match(text, pattern)) {
    std::cout << "匹配成功！" << std::endl;
} else {
    std::cout << "匹配失败！" << std::endl;
}
```

| 元字符 / 量词 | 含义                               | 例子                               |
| ------------- | ---------------------------------- | ---------------------------------- |
| **.**         | **匹配任意单个字符**               | **a.b 可以匹配 acb, a#b 等**       |
| *****         | **匹配 0 个或多个前面的字符**      | **a* 可以匹配 "","a","aa" 等**     |
| +             | 匹配 1 个或多个前面的字符          | a+ 可以匹配 "a", "aa" 等           |
| ?             | 匹配 0 个或 1 个前面的字符         | colou?r 可以匹配 color 和 colour   |
| ^             | 匹配字符串的开头                   | ^Hello 只匹配以 Hello 开头的字符串 |
| $             | 匹配字符串的结尾                   | World$ 只匹配以 World 结尾的字符串 |
| []            | 匹配括号内的任意一个字符           | [abc] 可以匹配 a, b, 或 c          |
| [a-z]         | 匹配 a 到 z 之间的任意字符         | [0-9] 匹配任意数字                 |
| [^]           | 匹配不在括号内的任意字符           | [^0-9] 匹配任何非数字字符          |
| ()            | 捕获分组                           | (abc)+ 匹配一个或多个 abc          |
| \|            | 或，匹配左边或右边                 | (cat\|dog) 可以匹配 cat 或 dog     |
| \d            | 匹配任意数字字符，等同于 [0-9]     | \d+ 匹配一个或多个数字             |
| \w            | 匹配任意字母、数字或下划线         | \w+ 匹配一个或多个单词字符         |
| \s            | 匹配任意空白字符（空格，制表符等） | \s+ 匹配一个或多个空格             |
| {n}           | 匹配恰好 n 次                      | \d {3} 匹配三个数字                |
| {n,}          | 匹配至少 n 次                      | \d {3,} 匹配至少三个数字           |
| {n,m}         | 匹配 n 到 m 次                     | \d {3,5} 匹配三到五个数字          |

### vector 

- lambda表达式实现降序排序

```cpp
vector<int> v = {1,2,3,4,5};

sort(v.begin(),v.end(),[](int a,int b) {return a > b;});
```

- reverse()，将指定区域元素逆置

```cpp
reverse(v.begin(),v.end());
```

#### 向量的性能与优化

- vector会动态的管理内存，自动调整其容量以适应新增或删除的元素，频繁的内存分配可能影响性能
- 使用`reserve()`可以为向量提前分配足够内存，减少内存重新分配次数，提高性能

```cpp
vector<int> v;
v.reserve(1000);
cout << v.capacity();
```

- 收缩容量：使用`shrink_to_fit()`可以请求收缩向量的容量以匹配其大小，释放多余内存

```cpp
v.reserve(1000);
cout << v.capacity();

v.push_back(1);

v.shrink_to_fit();
cout << v.capacity();
```

### 关于迭代器

> 迭代器提供了一种方法 - 按顺序访问容器中的元素，而无需暴露容器的内部表示（eg：next指针）
>
> 像一个指针，但比指针更安全，因为它只能访问容器内的元素

#### ①使用迭代器

- 与指针不同，迭代器不是通过取地址符&获得的，而是由容器的方法（如begin(),end()）返回的
  - `begin()`负责**返回指向第一个元素的迭代器**
  - `end()`负责**返回尾元素的下一位置的迭代器**，即该迭代器指示的是一个容器中本不存在的“尾后”的元素
  - 特殊情况下，若容器为空，则begin和end返回的是同一个迭代器
- 通常情况下，我们**不清楚（不在意）**迭代器的准确类型，一般使用auto定义

#### ②迭代器运算

| 运算符           | 功能描述                                                     |
| ---------------- | ------------------------------------------------------------ |
| `*iter`          | 返回迭代器 `iter` 所指元素的引用                             |
| `iter->mem`      | 解引用 `iter` 并获取该元素的名为 `mem` 的成员，等价于 `(*iter).mem` |
| `++iter`         | 令 `iter` 指示容器中的下一个元素（迭代器向前移动一个位置）   |
| `--iter`         | 令 `iter` 指示容器中的上一个元素（迭代器向后移动一个位置）   |
| `iter1 == iter2` | 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等；反之，不相等 |
| `iter1 != iter2` | 判断两个迭代器是否不相等，若两个迭代器指示的不是同一个元素且不是同一个容器的尾后迭代器，则不相等 |

#### ③迭代器类型

- 通常来说我们无需知道迭代器的精确类型，那些拥有迭代器的标准库类型使用`iterator`或`const_iterator`来表示迭代器的类型
  - `const_iterator`和常量指针类型，对于其所指元素只能读
  - `iterator`是可读可写
- 若容器内对象是const，则迭代器只能为const_iterator类型；若对象不是const，则迭代器两种类型均可

```cpp
vector<int> v = {1,2,3};
vector<int> :: const_iterator it;

for (it = v.cbegin(); it != v.cend(); it++) {
    cout << *it << " ";
}
```

- 若对象是常量，`begin`和`end`返回`const_iterator`，若对象不是常量，返回`iterator`
- 如果一个容器非常量，我们可以通过`cbegin`和`cend`获得对应的常量迭代器

```cpp
auto it = v.cbegin();
```

#### ④解引用与成员访问操作

- `*it`就可以访问迭代器指向的容器元素，若容器中元素是一个类，就可以继续访问其成员，以`vector<string>`为例

```cpp
vector<string> v = {"hello","world",""};

for (auto it = v.begin(); it != v.end(); ++it) {
    if ((*it).empty()) {
        cout << "empty string" << endl;
    }
}
```

- 箭头运算符`->`
  - 为了简化`(*it).empty()`这类表达式，C++定义了`->`，其可以**将解引用与成员访问两个操作结合在一起**
  - 即`it->empty()` == `(*it).empty()`

#### ⑤vector与string迭代器支持的运算

| 运算                 | 功能描述                                                     |
| -------------------- | ------------------------------------------------------------ |
| `iter + n`           | 迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置 |
| `iter - n`           | 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置 |
| `iter1 += n`         | 迭代器加法的复合赋值语句，将 `iter1` 加 `n` 的结果赋给 `iter1` |
| `iter1 -= n`         | 迭代器减法的复合赋值语句，将 `iter1` 减 `n` 的结果赋给 `iter1` |
| `iter1 - iter2`      | **两个迭代器相减的结果是它们之间的距离（int）**，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，**如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者**。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |

### 数组

- 显示初始化数组

> 如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来
>
> 如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值

```cpp
const unsigned sz = 3;
int a1[sz] = {1,2,3};
int a2[] = {1,2,3};//没有显示指定大小，编译器推断出是3
int a3[5] = {1,2,3};//剩余元素被初始化为0，等价于{1,2,3,0,0}
```

- 数组不允许拷贝与赋值

```cpp
int a4[] = a2;//这是错误的
```

#### ①数组的一系列声明

- ==关于数组引用，后续实践到再继续加深==

```cpp
int* p1[3];//p1 是一个数组，数组内的元素都是int*类型的
//int& p2[3];//错误,C++中不能定义“引用的数组”
int arr[5] = {1,2,3,4,5};
int (*p2)[5] = &arr;//p2是一个指针，指向一个“含有 5 个 int 的数组”，注意与p1区别开
```

#### ②指针与数组

- **在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针**

```cpp
cout << "第一个元素地址" << &arr[0] << endl;
cout << "数组首地址" << &arr << endl;//这是整个数组的地址（就是数组首地址）
cout << "数组首地址" << arr << endl;//数组退化为指针，实际上还是数组地址（首地址）
```

- 数组的指针，也是迭代器，可以完成像vector，string迭代器一样的功能

```cpp
int arr[5] = {1,2,3,4,5};
int* p = arr;

++p;
cout << *p;//2
```

- 奇淫技巧：像迭代器一样遍历数组元素（需要指向数组尾元素下一位置的指针 - 像迭代器的end()）一样，多维数组也是一样的道理

```cpp
int arr[5] = {1,2,3,4,5};
int* end = arr + 5;

for (auto* it = arr; it < end; it++) {
    cout << *it << " ";
}
```

- C++11提供了上面所说的 - 指向数组尾元素下一位置的指针

```cpp
int arr[5] = {1,2,3,4,5};

int* beg = begin(arr);
int* e = end(arr);
for (auto* it = beg; it < e; ++it)
    cout << *it << " ";
```

- 和迭代器一样，两个指针相减的结果是它们之间的距离

- 解引用与指针运算的交互 - 允许解引用指针运算的结果（如果还是指针的话）

```cpp
int ia[] = {0,2,4,6,8};
int last = *(ia+4);
std::cout << "last is " << last << std::endl;//8
```

- 高论：对数组执行下标运算，实际上就是对指向数组元素的指针的解引用

```cpp
int arr[] = {1,2,3,4,5};
// arr[4] 和 *(arr + 4)实际是一样的
```

