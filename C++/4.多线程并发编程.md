### 1. 前言

#### 1.1 进程与线程

- 进程是资源分配的基本单位，线程是调度的基本单位
- 进程是一个程序的**运行实例**，线程是指进程中**独立的执行流程**
- 一个进程可以有多个线程，多个线程可以并发执行
- 不同的进程拥有不同的地址空间，同一进程下的线程共享进程的地址空间

### 2. std::thread

#### 2.1 创建线程

- `std::thread`创建两个线程，分别执行两个函数
  - 输出结果分析：首先线程t2会执行func2，执行到读取x时，会被阻塞，但此时线程t1仍在执行，因此在打印*func2执行,读取数字x =后*，继续打印*func1执行*，在接收到用户输入后，再将用户输入的数打印出来
  - 以上说明了多线程可以并发执行，而非单一的按顺序单个执行

```cpp
void func1 () {
    cout << "func1执行" << endl;
}

void func2 (int x) {
    cout << "func2执行,读取数字x = " << x << endl;
}

int main () {
    int x;
    cin >> x;
    std::thread t2(func2,x);
    std::thread t1(func1);

    t1.join();
    t2.join();

    cout << "主线程执行完毕" << endl;

    return 0;
}
```

```mark
输入12，最终输出：
func2执行,读取数字x = func1执行12
主线程执行完毕
```

- 线程执行**有引用参数的函数**
  - std::thread在传递一个参数时，是以**右值**传递的
  - 因此当执行下面代码时，编译器会报错（通过thread传递了左值）
  - 传递左值可以使用`std::ref`和`std::cref`
    - `std::ref`可以包装按引用传递的值为右值
    - `std::cref`可以包装按const引用传递的值为右值

```cpp
void threadfunc1(int& arg1,int arg2) { // 参数1为左值
    arg1 = arg2;
    cout << "arg1 = " << arg1 << endl;
}

int main () {
    cout << "主线程开始执行" << endl;

    int a = 100,b = 200;
    std::thread t1(threadfunc1,a,b); // error
    t1.join();

    cout << "主线程执行完毕" << endl;
    return 0;
}
```

```cpp
std::thread t1(threadfunc1,std::ref(a),b); // 改为这样即可
std::thread t1(threadfunc1,std::cref(a),b); // 若是const引用则这么传
```

#### 2.2 join()、detach()与joinable()

- `join()`

  - 作用：用来**等待一个线程执行完毕**，若该线程还未执行完毕，则当前线程（一般是主线程）会被阻塞，直至该线程执行完毕主线程才继续执行
  - 当调用`t1.join()`时，**主线程会阻塞，直至线程t1执行完分配的任务**
  - 为什么需要用`join()`：还是以上面的代码为例，如果给线程分配任务后并未使用`join()`等待线程执行完毕，主进程结束后t1和t2均不会调用其析构函数，程序可能会直接结束/崩溃

  ```cpp
  void func1 () {
      cout << "run new thread!" << endl;
      _sleep(2000);
  }
  
  int main () {
      cout << "主线程开始执行" << endl;
  
      std::thread t1(func1);
      if (t1.joinable()) {
          t1.join();
  
          //t1.detach();
      }
  
      cout << "主线程执行完毕" << endl;
      return 0;
  }
  // 输出
  主线程开始执行
  run new thread!
  （会等待2s后再输出下一行），说明此时主线程被阻塞
  主线程执行完毕
  ```

- `detach()`

  - 作用：**让线程脱离(detach)主线程的控制，独立运行**，即我不再管这个线程了，让它自己跑完后，资源由OS自动回收
  - 如果线程被detach，就不能再join了，因为此时线程已经无法连接了
  - 对于一个线程，`join()`和`detach()`只能执行一个
  - 若一个线程既没有执行`join()`也没有执行`detach()`，在程序结束后会引发异常

  ```cpp
  void func1 () {
      cout << "run new thread!" << endl;
      _sleep(2000);
  }
  
  int main () {
      cout << "主线程开始执行" << endl;
  
      std::thread t1(func1);
      if (t1.joinable()) {
          //t1.join();
  
          t1.detach();
      }
  
      cout << "主线程执行完毕" << endl;
      return 0;
  }
  // 输出
  主线程开始执行
  主线程执行完毕 
  (即主线程未被阻塞，线程t1被分离，不归主线程管理了)
  ```

- `joinable()`

  - 作用：判断线程是否可执行`join()`，返回true / false

#### 2.3 std::this_thread

> 在C++中，`this_thread`类提供了一些关于**当前线程的功能函数** 

|      | 使用                            | 说明                                  |
| ---- | ------------------------------- | ------------------------------------- |
| 1    | std::this_thread::sleep_for()   | 当前线程**休眠指定的时间**            |
| 2    | std::this_thread::sleep_until() | 当前线程**休眠直到指定时间点**        |
| 3    | std::this_thread::yield()       | 当前线程**让出CPU**，允许其他线程运行 |
| 4    | std::this_thread::get_id()      | 获取当前线程的ID                      |

```cpp
void my_thread () {
    cout << "thread " << std::this_thread::get_id() << " start" << endl;
    for (int i = 0; i < 5; ++i) {
        cout << "thread " << std::this_thread::get_id() << " running" << i << endl;
        std::this_thread::yield();
        std::this_thread::sleep_for(std::chrono::milliseconds(200));//sleep 200ms
    }
    cout << "thread " << std::this_thread::get_id() << "end " << endl;
}

int main () {
    cout << "主线程开始执行" << endl;

    std::thread t1(my_thread);
    std::thread t2(my_thread);
    t1.join();
    t2.join();

    cout << "主线程执行完毕" << endl;
    return 0;
}
```

### 3.std::mutex

> 解决的就是OS那套同步互斥问题

#### 3.1 lock()与unlock()

- `std::mutex`是C++11最基本的**互斥量**，当一个线程将mutex锁住后，其他线程就不能访问mutex，直至该线程解锁该mutex

|      | 方法       | 说明                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| 1    | lock()     | 将mutex上锁                                                  |
| 2    | unlock()   | 将mutex解锁                                                  |
| 3    | try_lock() | **尝试将mutex上锁**。如果mutex未被上锁，则将其上锁并返回**true**；如果mutex已被锁则返回**false** |

```cpp
std::mutex mtx;
int num = 0; // 共享数据，需要互斥访问

void threadfunc(int &n) {
    for (int i = 0; i < 100; ++i) {
        mtx.lock();
        n++;
        mtx.unlock();
    }
}

int main () {
    std::thread thread_set[500]; // 创建500个线程
    for (std::thread& a : thread_set) {
        a = std::thread(threadfunc,std::ref(num));
    }

    for (std::thread& a : thread_set) {
        a.join();
    }
    cout << "num = " << num <<  std::endl; // 50000

    return 0;
}
```

- 上述代码，不加锁就可能出现 **两个线程同时读同一个旧值**，造成写丢失，虽然可能最终输出可能仍为50000，但这是“偶然正确”的结果，多次运行后可以发现最终num的值可能达不到50000，因为中间出现了写丢失

<img src="https://raw.githubusercontent.com/naplatte/Pictures/main/921808e5dbfacd3b64930e223f1d2743.png" alt="image-20251017173024040" style="zoom:80%;" />	

#### 3.2 std::lock_guard（RAII的思想）

- `std::lock_guard`是C++中的一个模板类，用于实现资源的自动加锁和解锁，基于RAII（资源的分配和释放绑定到对象的生命周期上）的设计理念
- 特点
  - 创建对象后，可以指定信号量对其上锁
  - 对象作用域结束后，自动解锁该信号量

```cpp
std::mutex mtx;

void thread_func() {
    std::lock_guard<std::mutex> lock(mtx); // 创建一个lock_guard对象，该对象拥有信号量mtx的使用权（上锁）
    cout << "thread running" << endl;
}

int main () {
    std::thread t1(thread_func);
    t1.join();
    cout << "main thread exit" << endl;
    return 0;
}
```

- **对比上面`lock()`、`unlock()`的代码，可以发现`lock_guard`相当方便，省去了手动lock和unlock的步骤**
- 手动lock、unlock的问题
  - 如果在unlock前程序出现异常，该互斥量将不会被释放（锁永远被占用->死锁）
  - 加锁必须要解锁，锁一多容易乱

#### 3.3 std::unique_lock（RAII的思想）

- `std::unique_lock`就是在RAII下的**可控加锁器**，同样也是一个模板类
- 对比`lock_guard`：支持更多操作 - 手动解锁再加锁等，**可以在不需要互斥量时合理将控制权让出**

```cpp
std::mutex mtx;

void thread_func() {
    std::unique_lock<std::mutex> lock(mtx); // 自动加锁
    cout << "thread running" << endl;

    lock.unlock(); // 手动解锁(lock_guard对象是不可以这样操作的)
     // 这里可以执行一些不需要加锁保护的代码(把资源占有权合理的让出去)
    lock.lock(); // 再次加锁
     // 这里再执行需要加锁保护的代码
    
} // 离开作用域自动解锁

int main () {
    std::thread t1(thread_func);
    t1.join();
    cout << "main thread exit" << endl;
    return 0;
}
```

### 4.std::condition_variable

- `std::condition_variable`也是C++中的一个类，用于**实现线程间的条件变量和线程同步**，提供了**等待**和**通知**机制，使线程可以在某个条件被满足后被唤醒，或者满足某个条件后通知等待的线程（条件就是线程阻塞的原因 - 线程需要的资源）

|      | 方法         | 说明                                                         |
| ---- | ------------ | ------------------------------------------------------------ |
| 1    | wait()       | 使当前线程进入**阻塞态**，**（释放占用的资源）**直到被其他线程通过`notify_one()`或`notify_all()`函数唤醒。该函数**需要一个互斥锁作为参数，调用时会自动释放互斥锁，并在被唤醒后重新获取互斥锁** |
| 2    | wait_for()   | `wait_for()`: 使当前线程进入阻塞态**（释放占用的资源）**，最多等待一定的时间，直到被其他线程通过`notify_one()`或`notify_all()`函数唤醒，或者等待超时。该函数**需要一个互斥锁和一个时间段作为参数**，返回时有两种情况：**等待超时返回**`std::cv_status::timeout`，**被唤醒返回**`std::cv_status::no_timeout`。 |
| 3    | wait_until() | `wait_until()`: 使当前线程进入阻塞态，直到被其他线程通过`notify_one()`或`notify_all()`函数唤醒，**或者等待时间达到指定的绝对时间点**。该函数**需要一个互斥锁和一个绝对时间点作为参数**，返回时有两种情况：**时间到达返回**`std::cv_status::timeout`，**被唤醒返回**`std::cv_status::no_timeout`。 |
| 4    | notify_one() | `notify_one()`: 唤醒一个等待中的线程，**如果有多个线程在等待，则选择其中一个线程唤醒** |
| 5    | notify_all() | `notify_all()`: **唤醒所有等待中的线程**，使它们从等待状态返回 |

```cpp
std::mutex mtx;
std::condition_variable cv; // 条件变量
bool isReady = false; // 条件

void thread_func() {
    std::unique_lock<std::mutex> lock(mtx);
    while (! isReady) {
        cv.wait(lock); // 线程进入阻塞态，等待条件满足，释放对mtx的占有权
    }
    cout << "thread is notified" << endl;
}


int main() {
    std::thread t1(thread_func);

    std::this_thread::sleep_for(std::chrono::seconds(2));

    {
        std::lock_guard<std::mutex> lock(mtx); //lock将mtx上锁
        isReady = true;
    }
    // 作用域结束后，lock释放mtx

    cv.notify_one(); // 通知等待的线程
    t1.join();

    return 0;
}
```

### 5.std::atomic

- `std::atomic`提供了一种**无锁线程安全的数据访问机制**
- 其可以保证**对变量的所有操作都是原子的**，即多线程同时读写一个变量，不会出现脏数据的问题

```cpp
std::atomic<int> sum(0);

void thread_func() {
    for(int i = 0; i < 100; ++i) {
        sum++; // 这里之前我们是用加锁解锁的逻辑实现多线程对变量的互斥访问
    }
}

int main() {
    std::thread t1(thread_func);
    std::thread t2(thread_func);
    t1.join();
    t2.join();
    std::cout << sum << endl; //输出一定且只会为200
}
```

- 其他用法用到再补吧