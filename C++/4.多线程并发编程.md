### 1. 前言

#### 1.1 进程与线程

- 进程是资源分配的基本单位，线程是调度的基本单位
- 进程是一个程序的**运行实例**，线程是指进程中**独立的执行流程**
- 一个进程可以有多个线程，多个线程可以并发执行
- 不同的进程拥有不同的地址空间，同一进程下的线程共享进程的地址空间

### 2. std::thread

#### 2.1 创建线程

- `std::thread`创建两个线程，分别执行两个函数
  - 输出结果分析：首先线程t2会执行func2，执行到读取x时，会被阻塞，但此时线程t1仍在执行，因此在打印*func2执行,读取数字x =后*，继续打印*func1执行*，在接收到用户输入后，再将用户输入的数打印出来
  - 以上说明了多线程可以并发执行，而非单一的按顺序单个执行

```cpp
void func1 () {
    cout << "func1执行" << endl;
}

void func2 (int x) {
    cout << "func2执行,读取数字x = " << x << endl;
}

int main () {
    int x;
    cin >> x;
    std::thread t2(func2,x);
    std::thread t1(func1);

    t1.join();
    t2.join();

    cout << "主线程执行完毕" << endl;

    return 0;
}
```

```mark
输入12，最终输出：
func2执行,读取数字x = func1执行12
主线程执行完毕
```

- 线程执行**有引用参数的函数**
  - std::thread在传递一个参数时，是以**右值**传递的
  - 因此当执行下面代码时，编译器会报错（通过thread传递了左值）
  - 传递左值可以使用`std::ref`和`std::cref`
    - `std::ref`可以包装按引用传递的值为右值
    - `std::cref`可以包装按const引用传递的值为右值

```cpp
void threadfunc1(int& arg1,int arg2) { // 参数1为左值
    arg1 = arg2;
    cout << "arg1 = " << arg1 << endl;
}

int main () {
    cout << "主线程开始执行" << endl;

    int a = 100,b = 200;
    std::thread t1(threadfunc1,a,b); // error
    t1.join();

    cout << "主线程执行完毕" << endl;
    return 0;
}
```

```cpp
std::thread t1(threadfunc1,std::ref(a),b); // 改为这样即可
std::thread t1(threadfunc1,std::cref(a),b); // 若是const引用则这么传
```

#### 2.2 join()、detach()与joinable()

- `join()`

  - 作用：用来**等待一个线程执行完毕**，若该线程还未执行完毕，则当前线程（一般是主线程）会被阻塞，直至该线程执行完毕主线程才继续执行
  - 当调用`t1.join()`时，**主线程会阻塞，直至线程t1执行完分配的任务**
  - 为什么需要用`join()`：还是以上面的代码为例，如果给线程分配任务后并未使用`join()`等待线程执行完毕，主进程结束后t1和t2均不会调用其析构函数，程序可能会直接结束/崩溃

  ```cpp
  void func1 () {
      cout << "run new thread!" << endl;
      _sleep(2000);
  }
  
  int main () {
      cout << "主线程开始执行" << endl;
  
      std::thread t1(func1);
      if (t1.joinable()) {
          t1.join();
  
          //t1.detach();
      }
  
      cout << "主线程执行完毕" << endl;
      return 0;
  }
  // 输出
  主线程开始执行
  run new thread!
  （会等待2s后再输出下一行），说明此时主线程被阻塞
  主线程执行完毕
  ```

- `detach()`

  - 作用：**让线程脱离(detach)主线程的控制，独立运行**，即我不再管这个线程了，让它自己跑完后，资源由OS自动回收
  - 如果线程被detach，就不能再join了，因为此时线程已经无法连接了
  - 对于一个线程，`join()`和`detach()`只能执行一个
  - 若一个线程既没有执行`join()`也没有执行`detach()`，在程序结束后会引发异常

  ```cpp
  void func1 () {
      cout << "run new thread!" << endl;
      _sleep(2000);
  }
  
  int main () {
      cout << "主线程开始执行" << endl;
  
      std::thread t1(func1);
      if (t1.joinable()) {
          //t1.join();
  
          t1.detach();
      }
  
      cout << "主线程执行完毕" << endl;
      return 0;
  }
  // 输出
  主线程开始执行
  主线程执行完毕 
  (即主线程未被阻塞，线程t1被分离，不归主线程管理了)
  ```

- `joinable()`

  - 作用：判断线程是否可执行`join()`，返回true / false

#### 2.3 std::this_thread

> 在C++中，`this_thread`类提供了一些关于**当前线程的功能函数**

| 使用 | 说明                            |                                       |
| ---- | ------------------------------- | ------------------------------------- |
| 1    | std::this_thread::sleep_for()   | 当前线程**休眠指定的时间**            |
| 2    | std::this_thread::sleep_until() | 当前线程**休眠直到指定时间点**        |
| 3    | std::this_thread::yield()       | 当前线程**让出CPU**，允许其他线程运行 |
| 4    | std::this_thread::get_id()      | 获取当前线程的ID                      |

