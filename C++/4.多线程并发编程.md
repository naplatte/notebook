### 1. 前言

#### 1.1 进程与线程

- 进程是资源分配的基本单位，线程是调度的基本单位
- 进程是一个程序的**运行实例**，线程是指进程中**独立的执行流程**
- 一个进程可以有多个线程，多个线程可以并发执行
- 不同的进程拥有不同的地址空间，同一进程下的线程共享进程的地址空间

### 2. std::thread

#### 2.1 创建线程

- `std::thread`创建两个线程，分别执行两个函数
  - 输出结果分析：首先线程t2会执行func2，执行到读取x时，会被阻塞，但此时线程t1仍在执行，因此在打印*func2执行,读取数字x =后*，继续打印*func1执行*，在接收到用户输入后，再将用户输入的数打印出来
  - 以上说明了多线程可以并发执行，而非单一的按顺序单个执行

```cpp
void func1 () {
    cout << "func1执行" << endl;
}

void func2 (int x) {
    cout << "func2执行,读取数字x = " << x << endl;
}

int main () {
    int x;
    cin >> x;
    std::thread t2(func2,x);
    std::thread t1(func1);

    t1.join();
    t2.join();

    cout << "主线程执行完毕" << endl;

    return 0;
}
```

```mark
输入12，最终输出：
func2执行,读取数字x = func1执行12
主线程执行完毕
```

- 线程执行**有引用参数的函数**
  - std::thread在传递一个参数时，是以**右值**传递的
  - 因此当执行下面代码时，编译器会报错（通过thread传递了左值）
  - 传递左值可以使用`std::ref`和`std::cref`
    - `std::ref`可以包装按引用传递的值为右值
    - `std::cref`可以包装按const引用传递的值为右值

```cpp
void threadfunc1(int& arg1,int arg2) { // 参数1为左值
    arg1 = arg2;
    cout << "arg1 = " << arg1 << endl;
}

int main () {
    cout << "主线程开始执行" << endl;

    int a = 100,b = 200;
    std::thread t1(threadfunc1,a,b); // error
    t1.join();

    cout << "主线程执行完毕" << endl;
    return 0;
}
```

```cpp
std::thread t1(threadfunc1,std::ref(a),b); // 改为这样即可
std::thread t1(threadfunc1,std::cref(a),b); // 若是const引用则这么传
```

#### 2.2 join()、detach()与joinable()

- `join()`

  - 作用：用来**等待一个线程执行完毕**，若该线程还未执行完毕，则当前线程（一般是主线程）会被阻塞，直至该线程执行完毕主线程才继续执行
  - 当调用`t1.join()`时，**主线程会阻塞，直至线程t1执行完分配的任务**
  - 为什么需要用`join()`：还是以上面的代码为例，如果给线程分配任务后并未使用`join()`等待线程执行完毕，主进程结束后t1和t2均不会调用其析构函数，程序可能会直接结束/崩溃

  ```cpp
  void func1 () {
      cout << "run new thread!" << endl;
      _sleep(2000);
  }
  
  int main () {
      cout << "主线程开始执行" << endl;
  
      std::thread t1(func1);
      if (t1.joinable()) {
          t1.join();
  
          //t1.detach();
      }
  
      cout << "主线程执行完毕" << endl;
      return 0;
  }
  // 输出
  主线程开始执行
  run new thread!
  （会等待2s后再输出下一行），说明此时主线程被阻塞
  主线程执行完毕
  ```

- `detach()`

  - 作用：**让线程脱离(detach)主线程的控制，独立运行**，即我不再管这个线程了，让它自己跑完后，资源由OS自动回收
  - 如果线程被detach，就不能再join了，因为此时线程已经无法连接了
  - 对于一个线程，`join()`和`detach()`只能执行一个
  - 若一个线程既没有执行`join()`也没有执行`detach()`，在程序结束后会引发异常

  ```cpp
  void func1 () {
      cout << "run new thread!" << endl;
      _sleep(2000);
  }
  
  int main () {
      cout << "主线程开始执行" << endl;
  
      std::thread t1(func1);
      if (t1.joinable()) {
          //t1.join();
  
          t1.detach();
      }
  
      cout << "主线程执行完毕" << endl;
      return 0;
  }
  // 输出
  主线程开始执行
  主线程执行完毕 
  (即主线程未被阻塞，线程t1被分离，不归主线程管理了)
  ```

- `joinable()`

  - 作用：判断线程是否可执行`join()`，返回true / false

#### 2.3 std::this_thread

> 在C++中，`this_thread`类提供了一些关于**当前线程的功能函数** 

|      | 使用                            | 说明                                  |
| ---- | ------------------------------- | ------------------------------------- |
| 1    | std::this_thread::sleep_for()   | 当前线程**休眠指定的时间**            |
| 2    | std::this_thread::sleep_until() | 当前线程**休眠直到指定时间点**        |
| 3    | std::this_thread::yield()       | 当前线程**让出CPU**，允许其他线程运行 |
| 4    | std::this_thread::get_id()      | 获取当前线程的ID                      |

```cpp
void my_thread () {
    cout << "thread " << std::this_thread::get_id() << " start" << endl;
    for (int i = 0; i < 5; ++i) {
        cout << "thread " << std::this_thread::get_id() << " running" << i << endl;
        std::this_thread::yield();
        std::this_thread::sleep_for(std::chrono::milliseconds(200));//sleep 200ms
    }
    cout << "thread " << std::this_thread::get_id() << "end " << endl;
}

int main () {
    cout << "主线程开始执行" << endl;

    std::thread t1(my_thread);
    std::thread t2(my_thread);
    t1.join();
    t2.join();

    cout << "主线程执行完毕" << endl;
    return 0;
}
```

### 3.std::mutex

> 解决的就是OS那套同步互斥问题

#### 3.1 lock()与unlock()

- `std::mutex`是C++11最基本的**互斥量**，当一个线程将mutex锁住后，其他线程就不能访问mutex，直至该线程解锁该mutex

|      | 方法       | 说明                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| 1    | lock()     | 将mutex上锁                                                  |
| 2    | unlock()   | 将mutex解锁                                                  |
| 3    | try_lock() | **尝试将mutex上锁**。如果mutex未被上锁，则将其上锁并返回**true**；如果mutex已被锁则返回**false** |

```cpp
std::mutex mtx;
int num = 0; // 共享数据，需要互斥访问

void threadfunc(int &n) {
    for (int i = 0; i < 100; ++i) {
        mtx.lock();
        n++;
        mtx.unlock();
    }
}

int main () {
    std::thread thread_set[500]; // 创建500个线程
    for (std::thread& a : thread_set) {
        a = std::thread(threadfunc,std::ref(num));
    }

    for (std::thread& a : thread_set) {
        a.join();
    }
    cout << "num = " << num <<  std::endl; // 50000

    return 0;
}
```

- 上述代码，不加锁就可能出现 **两个线程同时读同一个旧值**，造成写丢失，虽然可能最终输出可能仍为50000，但这是“偶然正确”的结果，多次运行后可以发现最终num的值可能达不到50000，因为中间出现了写丢失

<img src="https://raw.githubusercontent.com/naplatte/Pictures/main/921808e5dbfacd3b64930e223f1d2743.png" alt="image-20251017173024040" style="zoom:80%;" />	

#### 3.2 std::lock_guard（RAII的思想）

- `std::lock_guard`是C++中的一个模板类，用于实现资源的自动加锁和解锁，基于RAII（资源的分配和释放绑定到对象的生命周期上）的设计理念
- 特点
  - 创建对象后，可以指定信号量对其上锁
  - 对象作用域结束后，自动解锁该信号量

```cpp
std::mutex mtx;

void thread_func() {
    std::lock_guard<std::mutex> lock(mtx); // 创建一个lock_guard对象，该对象拥有信号量mtx的使用权（上锁）
    cout << "thread running" << endl;
}

int main () {
    std::thread t1(thread_func);
    t1.join();
    cout << "main thread exit" << endl;
    return 0;
}
```

- **对比上面`lock()`、`unlock()`的代码，可以发现`lock_guard`相当方便，省去了手动lock和unlock的步骤**
- 手动lock、unlock的问题
  - 如果在unlock前程序出现异常，该互斥量将不会被释放（锁永远被占用->死锁）
  - 加锁必须要解锁，锁一多容易乱

#### 3.3 std::unique_lock（RAII的思想）

- `std::unique_lock`就是在RAII下的**可控加锁器**，同样也是一个模板类
- 对比`lock_guard`：支持更多操作 - 手动解锁再加锁等，**可以在不需要互斥量时合理将控制权让出**

```cpp
std::mutex mtx;

void thread_func() {
    std::unique_lock<std::mutex> lock(mtx); // 自动加锁
    cout << "thread running" << endl;

    lock.unlock(); // 手动解锁(lock_guard对象是不可以这样操作的)
     // 这里可以执行一些不需要加锁保护的代码(把资源占有权合理的让出去)
    lock.lock(); // 再次加锁
     // 这里再执行需要加锁保护的代码
    
} // 离开作用域自动解锁

int main () {
    std::thread t1(thread_func);
    t1.join();
    cout << "main thread exit" << endl;
    return 0;
}
```

### 4.std::condition_variable

- `std::condition_variable`也是C++中的一个类，用于**实现线程间的条件变量和线程同步**，提供了**等待**和**通知**机制，使线程可以在某个条件被满足后被唤醒，或者满足某个条件后通知等待的线程（条件就是线程阻塞的原因 - 线程需要的资源）

|      | 方法         | 说明                                                         |
| ---- | ------------ | ------------------------------------------------------------ |
| 1    | wait()       | 使当前线程进入**阻塞态**，**（释放占用的资源）**直到被其他线程通过`notify_one()`或`notify_all()`函数唤醒。该函数**需要一个互斥锁作为参数，调用时会自动释放互斥锁，并在被唤醒后重新获取互斥锁** |
| 2    | wait_for()   | `wait_for()`: 使当前线程进入阻塞态**（释放占用的资源）**，最多等待一定的时间，直到被其他线程通过`notify_one()`或`notify_all()`函数唤醒，或者等待超时。该函数**需要一个互斥锁和一个时间段作为参数**，返回时有两种情况：**等待超时返回**`std::cv_status::timeout`，**被唤醒返回**`std::cv_status::no_timeout`。 |
| 3    | wait_until() | `wait_until()`: 使当前线程进入阻塞态，直到被其他线程通过`notify_one()`或`notify_all()`函数唤醒，**或者等待时间达到指定的绝对时间点**。该函数**需要一个互斥锁和一个绝对时间点作为参数**，返回时有两种情况：**时间到达返回**`std::cv_status::timeout`，**被唤醒返回**`std::cv_status::no_timeout`。 |
| 4    | notify_one() | `notify_one()`: 唤醒一个等待中的线程，**如果有多个线程在等待，则选择其中一个线程唤醒** |
| 5    | notify_all() | `notify_all()`: **唤醒所有等待中的线程**，使它们从等待状态返回 |

```cpp
std::mutex mtx;
std::condition_variable cv; // 条件变量
bool isReady = false; // 条件

void thread_func() {
    std::unique_lock<std::mutex> lock(mtx);
    while (! isReady) {
        cv.wait(lock); // 线程进入阻塞态，等待条件满足，释放对mtx的占有权
    }
    cout << "thread is notified" << endl;
}


int main() {
    std::thread t1(thread_func);

    std::this_thread::sleep_for(std::chrono::seconds(2));

    {
        std::lock_guard<std::mutex> lock(mtx); //lock将mtx上锁
        isReady = true;
    }
    // 作用域结束后，lock释放mtx

    cv.notify_one(); // 通知等待的线程
    t1.join();

    return 0;
}
```

### 5.std::atomic

- `std::atomic`提供了一种**无锁线程安全的数据访问机制**		
- 其可以保证**对变量的所有操作都是原子的**，即多线程同时读写一个变量，不会出现脏数据的问题

```cpp
std::atomic<int> sum(0);

void thread_func() {
    for(int i = 0; i < 100; ++i) {
        sum++; // 这里之前我们是用加锁解锁的逻辑实现多线程对变量的互斥访问
    }
}

int main() {
    std::thread t1(thread_func);
    std::thread t2(thread_func);
    t1.join();
    t2.join();
    std::cout << sum << endl; //输出一定且只会为200
}
```

- 常用操作 

| 操作     | 示例                                            | 说明                                    |
| -------- | ----------------------------------------------- | --------------------------------------- |
| 读取     | `int x = a.load();`                             | 原子地读取值                            |
| 写入     | `a.store(10);`                                  | 原子地写入值                            |
| 自增     | `a++; ++a;`                                     | 原子自增                                |
| 自减     | `a--; --a;`                                     | 原子自减                                |
| 加法     | `a.fetch_add(5);`                               | 原子加 5（返回旧值）                    |
| 减法     | `a.fetch_sub(3);`                               | 原子减 3（返回旧值）                    |
| 比较交换 | `a.compare_exchange_strong(expected, desired);` | 如果当前值等于 expected，则写入 desired |
| 取值     | `int x = a;`                                    | 等价于 `.load()`                        |
| 赋值     | `a = 10;`                                       | 等价于 `.store(10)`                     |

- **关于CAS**

  - CAS：compare and swap，是并发编程的核心机制之一，几乎所有的**无锁**算法都依赖它

  - 解决了什么问题：假设有变量`x`，我们希望“只有当`x`的值**符合我的一个预期值**时，才把它改为新值”，而这个过程必须是**原子的**，不可被打断

  - 因为CAS只做三件事：比较、判断比较是否成立、成立则交换

    ```cpp
    int x = 5;
    if (x == 5)
        x = 10;
    ```

  - 在多线程环境下，上述比较+赋值的操作可能被其他线程打断

  - 两种函数

    - **compare_exchange_weak()**：可能会偶然失败（即使比较成立），但速度较快，适合在**循环（如自旋重试）**中使用

    - **compare_exchange_strong()**：不会出现偶然失败，但速度较慢，适合在单词判断中使用

  - CAS带上内存序参数

    - 修改成功时，按release去写
    - 修改失败时，按relaxed去读（只保证原子）

  ```cpp
  compare_exchange_weak(expected, desired,
                        std::memory_order_release,
                        std::memory_order_relaxed);
  ```

### 6.std::memory_order

- `std::memory_order`内存序：是用于原子操作内存顺序的**枚举类型**，其控制着原子操作在不同线程间的可见性和顺序保证，也决定了**原子操作与其他普通读写操作之间的执行顺序**
- 为什么需要`memory_order`：在多线程中，CPU和编译器可能为了优化性能而**重新排序指令**或**缓存某个值，不立即同步到主存**，这些优化虽然让单线程快了，但会影响多线程的执行效率
- `std::atomic`提供了原子操作，防止操作本身被中断；`std::memory_order`则进一步**控制这些操作在内存 层面的可见顺序**

- ==acquire与release（同步）==

  - **acquire（获取）相当于P操作**：**本操作之后的读写不能重排到它前面，就是优先它呗**

  - **release（释放）相当于V操作：本操作之前的读写不能重排到它后面，就是等别人读写完才能它干（优先别人）**

```cpp
std::atomic<int> x = 0;
bool ready = false;

//线程1
x.store(100,std::memory_order_release);
ready.store(true,std::memory_order_release);

//线程2
while (! ready.load(std::memory_order_acquire)){}
std::cout << x << std::endl;
```

- 六种 memory_order 的作用总览

| 名称                   | 含义                             | 典型用途                    | 是否同步 |
| ---------------------- | -------------------------------- | --------------------------- | -------- |
| `memory_order_relaxed` | 不保证顺序，仅保证原子性         | 计数器、统计信息            | ❌        |
| `memory_order_acquire` | 本操作之后的读写不能重排到它前面 | 用于读取“同步标志位”        | ✅        |
| `memory_order_release` | 本操作之前的读写不能重排到它后面 | 用于写入“同步标志位”        | ✅        |
| `memory_order_acq_rel` | 同时具备 acquire + release 语义  | 用于 read-modify-write 操作 | ✅        |
| `memory_order_seq_cst` | 全局顺序一致性（最严格）         | 默认、最安全但最慢          | ✅✅✅      |

### 7.thread_local

- thread_local是C++11引入的一个**存储期限修饰符**，表示**每个线程都会拥有该变量的一个独立副本**
  - 不同线程访问该变量时，互不影响
  - 每个线程第一次访问它时，会单独初始化
  - 线程结束后，该线程的副本也被销毁

- 下面代码为例，可以看到全局global_var最终被加到6（每个线程加了三次），而local_var在每个线程内部被独立的加了3次

  - 输出的第一行有点跳步（global_var直接是2了）的解释：

    - `Thread 1` 启动后，**global_var++** 可能被优化或延迟到执行后某一时刻；

      线程间切换顺序不固定；

      甚至 I/O 输出的缓冲也会导致打印顺序和真实执行顺序略有偏差。

```cpp
int global_var = 0; // 所有线程独享
thread_local int local_var = 0; // 每个线程独立的副本
std::mutex mtx; // 用于互斥访问全局变量
std::mutex cout_mtx;  // 新增互斥锁,确保输出不抢占

void worker(int id) {
    for (int i = 0; i < 3; ++i) {
        {
            std::lock_guard<std::mutex> lock(mtx);
            ++global_var;
            cout << "Thread " << id
                 << " global_var=" << global_var
                 << " local_var=" << ++local_var << endl;
        }
    }
}

int main() {
    thread t1(worker, 1);
    thread t2(worker, 2);
    t1.join();
    t2.join();
}
```

```markdown
D:\A_code\Cpp_STL\main.exe
Thread 2 global_var=1 local_var=1
Thread 2 global_var=2 local_var=2
Thread 2 global_var=3 local_var=3
Thread 1 global_var=4 local_var=1
Thread 1 global_var=5 local_var=2
Thread 1 global_var=6 local_var=3
```

