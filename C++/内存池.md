## 1.相关理论内容

### 1.1 内存池是什么

- 是一种**预分配内存并进行重复利用的技术**，通过**减少频繁的动态内存分配与释放操作**，提高程序运行效率
- 因为申请内存要涉及到**系统调用**，os由用户态 → 内核态，无疑会增大开销
- 内存池通常**预先分配一块较大的空间**，将其划分为多个小块，每次需要分配内存时直接从这块大的空间中分配（通过预分配和一些管理逻辑提高内存分配和释放效率）

### 1.2 内存池的作用

1. 首先就是上文提到的减少频繁的动态内存分配与释放，提高程序运行效率（降低系统调用频率）
2. 减少外碎片问题：频繁的`malloc/free`会使内存中大的空闲块越来越少
3. 分配时间更可靠：内存池可以使分配和释放操作的**耗时**更加可控和稳定，适合**实时OS**

### 1.3 内存池应用场景

- 游戏开发：大量小对象（粒子、子弹等）动态分配和释放很频繁
- 网络编程：大量请求和响应对象的频繁创建与销毁
- 内存管理库：`vector、deque`等容器内部使用内存池优化分配性能

- 实时OS：追求分配释放内存的稳定性
- 高性能计算：高性能计算程序中，频繁分配释放内存影响整个程序性能
- 服务器开发：web服务器 管理大量连接和请求

### 1.4 内存池的缺点

- 初始内存占用：内存池需要分配较大内存作为初始内存，可能会浪费一些内存
- 复杂：使用内存池分配内存比直接使用new/malloc更复杂
- 不适合大型对象：因为**内存池设计的初衷就是针对频繁分配的小对象**，而大型对象往往占用空间大，且分配不频繁

## 2. v1版本	

### 2.1 序

<img src="https://raw.githubusercontent.com/naplatte/Pictures/main/83442d0abb07ef8a78ad3c4f6e2bb863.png" alt="image-20251023162629002" style="zoom:67%;" />	

- 看懂架构

  - 维护一个哈希桶，每一项都对应一个MemoryPool，每个MemoryPool的总大小都是相同的（哈希桶管理多个内存池）
  - 每个内存池中有若干个**内存块**，**块与块之间通过链表连接起来**
    - 各内存池的块都是相同的，`MemoryPool`类中的`firstBlock_`指向内存池管理的**首个内存块**（实际指向的是首个内存块的第一个槽）
    - 每个内存块内有若干个**槽**，对于**同一个内存池内，槽的大小是相同的**
    - 不同内存池之间，槽的大小是不同的，最小为8B，往上以8的倍数递增，**最多为512B**
  - 释放对象时，内存归还给内存池，此时内存池不会将内存还给系统，而是**将指向该内存的指针前插到链表`freeSlot_`中**（避免频繁申请/归还资源），之后每次申请内存时，就先在`freeSlot_`链表中找
  - 如果`freeSlot_`为空，则将`curSlot`所指的内存分配出去（`curSlot_`指向当前未被使用过且将要分配出去的下一个槽）
  - 若block中的空闲槽用完，则向OS申请新的block

- 每个MemoryPool的内部结构

  - 每个槽按**链表**的形式存储
  - 需要的数据：

  ```cpp
  int BlockSize_; // 内存块大小
  int SlotSize_; // 槽大小
  Slot* firstBlock_; // 指向内存池管理的首个内存块
  Slot* curSlot; // 指向当前未被使用过的槽（将要分配出去的下一个槽）
  std::atomic<Slot*> freeList_; // 指向空闲的槽（被使用后又被释放）
  Slot* lastSlot_; // 当前内存块中最后能够存放元素的位置标识（超过该位置需要申请新内存块）
  std::mutex mutexForBlock_;	
  ```

### 2.2 由思路游龙到代码

> 跟着思路，想到啥写啥

- 为什么会有哈希桶：因为内存池有很多个，写的是内存池，而不是1个内存池，每个内存池虽然总大小一样，里面内存块的大小一样，但内存池与内存池之间，内部槽大小是不一样的，因此当用户申请空间时，我们应选择合适的内存池去分配（实际是选择合适的槽对应的内存池），所以需要有一个东西去管理这些内存池，即是hashbucket

- 为什么叫哈希桶：哈希桶的核心功能就是根据用户需要的内存，选择一个拥有合适槽的内存池，这个过程就是一个将**内存大小映射到对应MemoryPool实例**的过程，这个映射的过程类似哈希函数key->value的过程。因为管理的是一个memoryPool数组（每一项都是内存池类的实例），每个memoryPool就像一个桶一样

- 哈希桶是怎么管理MemoryPool的

  - 管理内存池的创建与删除：类似工厂模式调用MemoryPool的构造，删除时将内存池中的内存块全部operator delete掉
  - 用户内存的申请与释放：需要有向内存池申请和释放内存的接口

- 在哈希桶的管理下，MemoryPool需要完成什么工作

  - （构造/析构）

  - 提供分配/释放内存的接口给哈希桶，分配就涉及到向OS申请新的块，分配与释放也涉及着下面的freelist，这也是自定义内存池的核心
  - freelist：保存之前被使用过，但已被释放的内存块（不直接给OS，先自己收着）——对应就会有cur内存块入队出队的问题

## 3. v2版本

### 3.0 前置内容

- 内存块：大小为8的倍数，最小为8B，对齐单位是8B，对齐的好处：CPU访问更快、避免跨行占用内存
- 最大内存块：256KB，同时也是该内存池系统可以接受的最大可分配内存（因为一次只能分配一个块，超过最大块时就只能去系统调用了）
- 空闲链表：每个线程都维护一个自己的空闲链表，而每类大小的内存块，都对应一个空闲链表（比如8B对应一个空闲链表、16KB对应一个空闲链表）
  - 即每个线程都有一个 `array<void*,FREE_LIST_SIZE> freeList_; `，这里free_list_size实际就是有”多少种“不同大小的内存块 的这个”种数“，而`void*`就是指向这个空闲链表头节点的指针
  - **当空闲链表中的空闲块未被分配时，其前8B指向下一空闲块的地址，当其被分配后，空间则分配给用户**

- 大小类别（size class）：相当于一个工具类（没有状态，只提供函数），把用户请求映射到threadcache的合适链表

### 3.1 三层内存池概述

> 内存池通过分层缓存架构来管理内存，主要包括以下三层

1. 线程本地缓存（ThreadCache）
   - 每个线程独立的内存缓存（这点有些和认知不同，认知里一个进程的所有线程都是共享进程的内存的，实际上也是这样的，只是为每个线程建立了内存缓存）
   - 无锁操作 - 快速分配和释放
   - 减少线程间竞争，提高并发性能
2. 中心缓存（CentralCache）
   - 管理多个线程共享的内存块
   - 通过自旋锁保护，确保线程安全
   - 批量从页缓存中获取内存，分配给线程缓存
3. 页缓存（PageCache）
   - 从OS获取大的内存块
   - 将大块内存切为小块，供中心线程使用
   - 负责内存的回收和再利用

<img src="https://raw.githubusercontent.com/naplatte/Pictures/main/0b5fa34099c1ac2573857d88e20546e6.png" alt="image-20251104185019088"  />	

### 3.3 线程本地缓存

- 为线程分配内存（检查本地是否有）、回收内存
- 与中心缓存交互（没内存时向中心缓存申请、内存过多时交换一部分给中心缓存）
- **优点：** 绝大多数内存分配/释放在本线程内完成，无锁竞争，速度极快

#### 3.3.1 内存分配相关

- 线程缓存给线程分配内存`allocate`：小于8B分8B，大于256KB系统调用，其他去算（先算需要多少大小的内存块 - getIndex(size) 输入大小就可以算出对应空闲链表下标（索引）），若空闲链表中还有内存块，则分配，若空闲链表为空，则从中心缓存中拿内存，即下面的函数；
- 线程缓存从中心缓存拿内存`fetchFromCentralCache(size_t index)`，输入index，即表示需要“多大”的内存块，调用中心缓存拿内存块的接口即可，之后把申请到的内存块加入到自己的空闲链表中。**（若中心缓存没有可提供的内存块，则直接返回nullptr，而不是向页缓存再申请，因为下层仅能申请上层服务，不能跨层提供服务）**

#### 3.3.2 **内存释放相关**



### 3.4 中心缓存

- 管理从页缓存获得的内存块
- 为多个线程缓存提供内存分配服务
- 实现内存的跨线程复用

#### 3.4.1 spanTracker

- 用于管理从页缓存获取的内存块（span）
  - 当中心缓存需要内存时，会向页缓存申请一个**大块内存（span）**，spantracker就是负责跟踪这些大块内存，确保每个块的使用和释放都能得到管理
  - 大块内存通常占多个页，中心缓存在使用时，**将其分解为多个小块**（对于1个span，切成的小块是固定大小的 - 就是哪种大小类别的内存块用完了，就申请一个span，切成对应大小的内存块）

#### 3.4.2 内存分配相关

- `fetchRange()`：从中心缓存中取出指定大小（index）的内存块

### 3.5 页缓存

#### 3.5.1 

