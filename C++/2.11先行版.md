## 记录非系统学习但用到的C++11

### 1.constexpr

- `const expression`常量表达式的缩写
- 显示声明**在编译期就能求值的对象或函数**

> const = 不可修改，constexpr = **不仅不可改，而且希望编译器在编译阶段就把结果算出来**

- 例子：RL代码中

```cpp
constexpr double GAMMA = 0.9;//折扣因子
constexpr double THETA = 1e-6;//收敛阈值 - 到达阈值后停止迭代
```

### 2.using关键字

- 用法一：最常用，using + 命名空间

```cpp
using namespace std;
using std::cout;
using std::endl;
```

- 用法二：`using`类型别名（C++11）

```cpp
//相当于typedef vector<int> v;
using v = vector<int>;
//也可以是多层嵌套
using Grid = vector<vector<StateInfo>>;
```

- 用法三：`using`模板别名（C++11）

```cpp
template<typename T>
using Vec = vector<T>;
Vec<int> vi;//相当于vector<int> vi;
```

### 3.auto + 范围循环

- 各写法及含义（const ，& ）：这个就**类似于函数传参，一般都传引用，如果不修改元素，就传常量引用**

| 写法                    | 做了什么                               | 何时用                                     |
| ----------------------- | -------------------------------------- | ------------------------------------------ |
| for (auto i : v)        | 按值拷贝每个元素到i，不能更改容器元素  | 元素很小且不需要改动原数据，不在乎拷贝开销 |
| for (auto& i : v)       | 按引用绑定每个元素到i，可修改容器元素  | 需要就地修改元素                           |
| for (const auto& i : v) | 按常量引用绑定到元素，不能修改容器元素 | 最常见✔️元素体积不小、且只读不改            |

### 4.boolalpha与noboolalpha

- `std::boolalpha`是一个流操作符，用于控制bool值在输入输出流中的表现形式

> 默认情况下，布尔值输出为 `0`（表示 `false`）和 `1`（表示 `true`）。
>
> 使用 `std::boolalpha` 后，布尔值会以 **字符串形式** 输出：`true` 或 `false`。
>
> 搭配 `std::noboolalpha` 使用，可以恢复默认行为（输出为 `0` 和 `1`）。

```cpp
bool truth = true;
std::cout << std::boolalpha; // 启用布尔值的true/false输出
std::cout << "The truth is: " << truth << std::endl; //输出true
```

### 5.lambda表达式

- 匿名函数，对比普通函数，主要作用是在**需要函数的地方直接写一个小的内联函数**，而不用单独去声明和定义一个函数

```cpp
//不捕获外部变量
for_each(v.begin(),v.end(),[](int x) {
    cout << x << " ";
});
cout << endl;

//按引用捕获所有外部变量
for_each(v.begin(),v.end(),[&](int& x) {
    x *= 2;
});
```

- **捕获列表**
  - 不捕获任何外部变量的话，函数只能访问参数和全局变量

| [ ]        | 不捕获任何外部变量         |
| ---------- | -------------------------- |
| **[&]**    | **按引用捕获所有外部变量** |
| **[=]**    | **按值捕获所有外部变量**   |
| **[x,&y]** | **按值捕获x，按引用捕获y** |

<img src="https://raw.githubusercontent.com/naplatte/Pictures/main/116babba4a1031a2a9c2f79160235f23.png" alt="image-20250929201859399" style="zoom: 67%;" />	

- 常见应用：降序排序

```cpp
std::sort(data.begin(), data.end(), [](int a, int b) -> bool {
    return a > b;
});
```

### 6.移动语义

- 移动语义：允许**资源所有权**从一个对象**转移到**另一个对象，从而避免不必要的拷贝，提升性能
- C++标准库中string类的拷贝赋值为深拷贝，以下面代码为例
  - 初始时，str1、str2各管理一片内存，存储字符串内容
  - 执行`str2 = str1`后，**str2首先释放当前对象，再重新分配一片内存存储str1的内容**
  - 可见深拷贝是需要一定的性能消耗

```cpp
string str1 = "hello";
string str2 = "world";

str2 = str1;
```

- 移动构造与移动赋值

> **移动赋值（Move Assignment）** 是把一个右值对象（临时对象或即将销毁的对象）的 **资源所有权** 直接“搬到”另一个对象，而不是复制内容。
>
> 步骤通常如下：
>
> 1. **释放目标对象原来的资源**（避免内存泄漏）。
> 2. **把源对象的资源指针或句柄直接赋值给目标对象**。
> 3. **清空源对象的状态**（比如把指针设为 `nullptr`，大小设为 0），使它析构时不会重复释放。

```cpp
class MoveExample {
public:
    // 构造函数
    MoveExample(int size) : size_(size),data_(new int[size]) {
        std::cout << "构造函数执行" << std::endl;
    }

    // 拷贝构造函数
    MoveExample(const MoveExample& obj) : size_(obj.size_),data_(new int[obj.size_]) {
        std::copy(obj.data_, obj.data_ + size_, data_);
        std::cout << "拷贝构造执行" << std::endl;
    }

    // 移动构造函数
    MoveExample(MoveExample&& obj) noexcept : size_(obj.size_),data_(obj.data_) {
        obj.size_ = 0;
        obj.data_ = nullptr;
        std::cout << "移动构造执行" << std::endl;
    }

    // 拷贝赋值运算符（深拷贝）
    MoveExample& operator=(const MoveExample& obj) {
        std::cout << "拷贝赋值执行" << std::endl;
        if (this == &obj) {
            return *this;
        }
        else {
            // 深拷贝的过程就是重新分配内存，拷贝数据
            delete[] data_;
            this->size_ = obj.size_;
            this->data_ = new int[size_];
            std::copy(obj.data_,obj.data_ + size_,this->data_);
            return *this;
        }
    }

    // 移动赋值运算符
    MoveExample& operator=(MoveExample&& obj) noexcept {
        std::cout << "移动赋值运算符执行" << std::endl;
        if (this == &obj) {
            return *this;
        }
        else {
            delete[] data_;
            this->size_ = obj.size_;
            this->data_ = obj.data_;
            obj.size_ = 0;
            obj.data_ = nullptr;
            return *this;
        }
    }

    // 析构函数
    ~MoveExample() {
        delete [] data_;
        std::cout << "析构函数执行" << std::endl;
    }
    
private:
    int size_;
    int* data_;
};

int main() {
    SetConsoleOutputCP(CP_UTF8); // 设置输出为 UTF-8
    SetConsoleCP(CP_UTF8);       // 设置输入为 UTF-8

    MoveExample obj1(100);  // 构造函数执行
    MoveExample obj2 = obj1; // 拷贝构造执行
    MoveExample obj3 = MoveExample(200); // 这里是typename()创建了一个临时对象，现代编译器会应用 RVO（返回值优化）/Copy Elision，直接在 obj3 内存上构造临时对象，所以移动构造函数不会触发，只触发构造函数

    MoveExample obj4(300); // 构造函数执行
    obj4 = obj1; // 拷贝赋值执行
    obj4 = MoveExample(400); // 构造函数执行（临时对象）,移动赋值运算符执行
    
    //析构 * 5次（四个对象+一个临时对象）

    return 0;
}
```

