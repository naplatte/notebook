## 记录非系统学习但用到的C++11

### 1.constexpr

- `const expression`常量表达式的缩写
- 显示声明**在编译期就能求值的对象或函数**

> const = 不可修改，constexpr = **不仅不可改，而且希望编译器在编译阶段就把结果算出来**

- 例子：RL代码中

```cpp
constexpr double GAMMA = 0.9;//折扣因子
constexpr double THETA = 1e-6;//收敛阈值 - 到达阈值后停止迭代
```

### 2.using关键字

- 用法一：最常用，using + 命名空间

```cpp
using namespace std;
using std::cout;
using std::endl;
```

- 用法二：`using`类型别名（C++11）

```cpp
//相当于typedef vector<int> v;
using v = vector<int>;
//也可以是多层嵌套
using Grid = vector<vector<StateInfo>>;
```

- 用法三：`using`模板别名（C++11）

```cpp
template<typename T>
using Vec = vector<T>;
Vec<int> vi;//相当于vector<int> vi;
```

### 3.auto + 范围循环

- 各写法及含义（const ，& ）：这个就**类似于函数传参，一般都传引用，如果不修改元素，就传常量引用**

| 写法                    | 做了什么                               | 何时用                                     |
| ----------------------- | -------------------------------------- | ------------------------------------------ |
| for (auto i : v)        | 按值拷贝每个元素到i，不能更改容器元素  | 元素很小且不需要改动原数据，不在乎拷贝开销 |
| for (auto& i : v)       | 按引用绑定每个元素到i，可修改容器元素  | 需要就地修改元素                           |
| for (const auto& i : v) | 按常量引用绑定到元素，不能修改容器元素 | 最常见✔️元素体积不小、且只读不改            |

### 4.boolalpha与noboolalpha

- `std::boolalpha`是一个流操作符，用于控制bool值在输入输出流中的表现形式

> 默认情况下，布尔值输出为 `0`（表示 `false`）和 `1`（表示 `true`）。
>
> 使用 `std::boolalpha` 后，布尔值会以 **字符串形式** 输出：`true` 或 `false`。
>
> 搭配 `std::noboolalpha` 使用，可以恢复默认行为（输出为 `0` 和 `1`）。

```cpp
bool truth = true;
std::cout << std::boolalpha; // 启用布尔值的true/false输出
std::cout << "The truth is: " << truth << std::endl; //输出true
```

### 5.lambda表达式

#### ①基本应用

- 匿名函数，对比普通函数，主要作用是在**需要函数的地方直接写一个小的内联函数**，而不用单独去声明和定义一个函数

```cpp
//不捕获外部变量
for_each(v.begin(),v.end(),[](int x) {
    cout << x << " ";
});
cout << endl;

//按引用捕获所有外部变量
for_each(v.begin(),v.end(),[&](int& x) {
    x *= 2;
});
```

- **捕获列表**
  - 不捕获任何外部变量的话，函数只能访问参数和全局变量

| [ ]        | 不捕获任何外部变量         |
| ---------- | -------------------------- |
| **[&]**    | **按引用捕获所有外部变量** |
| **[=]**    | **按值捕获所有外部变量**   |
| **[x,&y]** | **按值捕获x，按引用捕获y** |

<img src="https://raw.githubusercontent.com/naplatte/Pictures/main/116babba4a1031a2a9c2f79160235f23.png" alt="image-20250929201859399" style="zoom: 67%;" />	

- 常见应用：降序排序

```cpp
std::sort(data.begin(), data.end(), [](int a, int b) -> bool {
    return a > b;
});
```

#### ②lambda的底层原理

- 一言蔽之：**编译器生成一个匿名类，并在其中重载`operator ()`**

```cpp
// 例如
int x = 10;
auto f = [x]() {return x + 1;};
```

- 上面的代码中，编译器会自动生成一个**匿名类**，其中有一个成员变量存储捕获的值x，有一个`operator()`实现lambda的功能

```cpp
// 编译器大概会生成下面一样的类（伪代码）
class SomeLambda {
    int x;  // 捕获的值（按值捕获）

public:
    SomeLambda(int x_) : x(x_) {}

    int operator()() const { // 注意这里的 const！
        return x + 1;
    }
};
```

#### ③可变lambda

- lambda的功能默认是不能改变捕获变量的值的
- 原因：上述对()的重载可以注意到，是有const的
- 通过`mutable`关键字，可以允许修改捕获的变量（注意需要引用捕获）

```cpp
int num = 100;
auto f = [&num] () mutable {num++;};
f();
std::cout << "num = " << num; // num = 101
```

### 6.移动语义

- 移动语义：允许**资源所有权**从一个对象**转移到**另一个对象，从而避免不必要的拷贝，提升性能
- C++标准库中string类的拷贝赋值为深拷贝，以下面代码为例
  - 初始时，str1、str2各管理一片内存，存储字符串内容
  - 执行`str2 = str1`后，**str2首先释放当前对象，再重新分配一片内存存储str1的内容**
  - 可见深拷贝是需要一定的性能消耗

```cpp
string str1 = "hello";
string str2 = "world";

str2 = str1;
```

- 移动构造与移动赋值

> **移动赋值（Move Assignment）** 是把一个右值对象（临时对象或即将销毁的对象）的 **资源所有权** 直接“搬到”另一个对象，而不是复制内容。
>
> 步骤通常如下：
>
> 1. **释放目标对象原来的资源**（避免内存泄漏）。
> 2. **把源对象的资源指针或句柄直接赋值给目标对象**。
> 3. **清空源对象的状态**（比如把指针设为 `nullptr`，大小设为 0），使它析构时不会重复释放。

```cpp
class MoveExample {
public:
    // 构造函数
    MoveExample(int size) : size_(size),data_(new int[size]) {
        std::cout << "构造函数执行" << std::endl;
    }

    // 拷贝构造函数
    MoveExample(const MoveExample& obj) : size_(obj.size_),data_(new int[obj.size_]) {
        std::copy(obj.data_, obj.data_ + size_, data_);
        std::cout << "拷贝构造执行" << std::endl;
    }

    // 移动构造函数
    MoveExample(MoveExample&& obj) noexcept : size_(obj.size_),data_(obj.data_) {
        obj.size_ = 0;
        obj.data_ = nullptr;
        std::cout << "移动构造执行" << std::endl;
    }

    // 拷贝赋值运算符（深拷贝）
    MoveExample& operator=(const MoveExample& obj) {
        std::cout << "拷贝赋值执行" << std::endl;
        if (this == &obj) {
            return *this;
        }
        else {
            // 深拷贝的过程就是重新分配内存，拷贝数据
            delete[] data_;
            this->size_ = obj.size_;
            this->data_ = new int[size_];
            std::copy(obj.data_,obj.data_ + size_,this->data_);
            return *this;
        }
    }

    // 移动赋值运算符
    MoveExample& operator=(MoveExample&& obj) noexcept {
        std::cout << "移动赋值运算符执行" << std::endl;
        if (this == &obj) {
            return *this;
        }
        else {
            delete[] data_;
            this->size_ = obj.size_;
            this->data_ = obj.data_;
            obj.size_ = 0;
            obj.data_ = nullptr;
            return *this;
        }
    }

    // 析构函数
    ~MoveExample() {
        delete [] data_;
        std::cout << "析构函数执行" << std::endl;
    }
    
private:
    int size_;
    int* data_;
};

int main() {
    SetConsoleOutputCP(CP_UTF8); // 设置输出为 UTF-8
    SetConsoleCP(CP_UTF8);       // 设置输入为 UTF-8

    MoveExample obj1(100);  // 构造函数执行
    MoveExample obj2 = obj1; // 拷贝构造执行
    MoveExample obj3 = MoveExample(200); // 这里是typename()创建了一个临时对象，现代编译器会应用 RVO（返回值优化）/Copy Elision，直接在 obj3 内存上构造临时对象，所以移动构造函数不会触发，只触发构造函数

    MoveExample obj4(300); // 构造函数执行
    obj4 = obj1; // 拷贝赋值执行
    obj4 = MoveExample(400); // 构造函数执行（临时对象）,移动赋值运算符执行
    
    //析构 * 5次（四个对象+一个临时对象）

    return 0;
}
```

### 7.智能指针

#### ①原生指针的问题

- 首先明确指针的作用 - 允许程序员**直接管理内存**，但却存在以下问题
- 内存泄漏：new了没delete
- 悬挂指针：指针指向已被释放/未初始化的内存
- 双重释放：多次释放同一内存区域

#### ②为什么智能指针好

- 自动销毁：在**指针生命周期结束后**自动释放资源
- 引用计数：追踪引用数量，确保在最后一个引用结束时释放内存（类似共享内存共享页面那里）
- 避免内存泄漏：RAII机制自动管理资源生命周期
- 类型安全：提供跟严格的类型检查

#### ③std::unique_ptr

- 最大特点：**独占所有权（没有引用计数），一个对象只能由一个unique_ptr管理**，当这个unique_ptr生命周期结束时，会自动调用delete释放对象
- 如何判断生命周期
  - 局部变量生命周期在其对应大括号结束后终止
  - 全局/静态变量程序结束时才销毁
  - 动态分配的对象：delete后生命周期结束，对于unique_ptr不用管，自动管理生命周期（指针销毁时自动释放对象）
- 提供**默认构造、移动构造、指针构造、移动赋值**
- 示例类

```cpp
class Test {
public:
    Test(int val) : value(val) {
        std::cout << "构造函数执行" << value << std::endl;
    }
    ~Test() {
        std::cout << "析构函数执行" << value << std::endl;
    }
    void show () const {
        std::cout << "value = " << value << std::endl;
    }

private:
    int value;
};
```

- 创建unique_ptr对象

```cpp
std::unique_ptr<Test> ptr1(new Test(100));
ptr1->show();
```

- **使用make_unique：创建一个对象并返回一个std::unique_ptr管理，比上面的方法更安全简洁**（创建一个对象，并创建一个指针指向这个对象）

```cpp
auto ptr2 = std::make_unique<Test>(200); // 此时auto即unique_ptr类型 (200)括号中的参数会直接传给Test构造函数
ptr2->show();
```

- **移动语义 `std::move()`**

```cpp
std::unique_ptr<Test> ptr3 = std::move(ptr1);
if (! ptr1) {
    std::cout << "ptr1指向nullptr" << std::endl;
}
ptr3->show();
```

- 重置unique_ptr：`reset()函数`

```cpp
ptr2.reset(new Test(300));
ptr2->show();
```

#### ④std::shared_ptr

- 最大特点：**共享所有权**，允许多个shared_ptr指向一个对象，通过**计数**机制，管理资源生命周期（计数为0，自动释放资源）
- 背后依靠 - 控制块：存储**引用计数和指向实际对象的指针**，其中引用计数又分为两种
  - 强引用计数：表示多少个shared_ptr指向对象
  - 弱引用计数：表示多少个wake_ptr指向对象（不增加引用计数，类似文件系统中的软链接）
- 提供**默认构造、拷贝构造、移动赋值、拷贝赋值、移动赋值等操作**

- 创建shared_ptr对象

```cpp
std::shared_ptr<Test> ptr1(new Test(100));
```

- `make_shared`：创建一个对象并返回一个shared_ptr管理

```cpp
auto ptr = make_shared<Test> (Test(200));
```

- 拷贝构造共享所有权

```cpp
std::shared_ptr<Test> ptr2 = ptr1;
```

- 拷贝赋值共享所有权

> **注意区别：拷贝构造函数是“创建时的拷贝”，拷贝赋值运算符是“已经存在对象再被赋值时的拷贝”**

```cpp
std::shared_ptr<Test> ptr1(new Test(100));
auto ptr3 = ptr1;
```

- 移动构造

```cpp
std::shared_ptr<Test> ptr4 = std::move(ptr1);
```

- 移动赋值

```cpp
std::shared_ptr<Test> ptr1(new Test(100));
auto ptr5 = std::move(ptr1);
```

- `reset()`重置

```cpp
ptr1.reset(new Test(10));
```

#### ⑤std::weak_ptr

- 最大特点：**不拥有对象所有权，不影响对象的生命周期**
- **从`shared_ptr`生成，通过`weak_ptr`可以访问`shared_ptr`管理的对象**,**`std::weak_ptr` 不能单独用来管理对象，它必须依附于一个 `std::shared_ptr` 才能工作**
- 存在即合理（作用）：解决`shared_ptr`可能的**循环引用**问题（双方互相引用，计数值永不为0，释放不了资源，类似死锁）
- 循环引用示例：看我注释吧，这里挺绕的

```cpp
class B; // 前向声明

class A {
public:
    std::shared_ptr<B> ptrB;

    A() {
        std::cout << "A构造" << std::endl;
    }
    ~A() {
        std::cout << "A析构" << std::endl;
    }
};

class B {
public:
    std::shared_ptr<A> ptrA;

    B() {
        std::cout << "B构造" << std::endl;
    }
    ~B() {
        std::cout << "B析构" << std::endl;
    }
};

int main () {
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    {
        std::shared_ptr<A> a = std::make_shared<A>(); // 创建智能指针a管理一个A的对象x，a是shared_ptr<A>类型
        std::shared_ptr<B> b = std::make_shared<B>(); // 创建智能指针b管理一个B的对象y，b是shared_ptr<B>类型
        a->ptrB = b; // x的成员ptrB指向b，而b指向y，因此即x指向y
        b->ptrA = a; // y的成员ptrA指向a，而a指向x，因此即y指向x
        // 此时即出现了x和y的循环引用，此时x和y上的计数均为2
    }
    //a和b都是局部变量，作用域结束后，a,b释放，此时x和y上的计数均为1，因此x和y都不会执行自己的析构函数
    std::cout << "Exiting main..." << std::endl;
    return 0;
}
// 运行后对象a b的析构函数均不会执行，即使离开作用域，但其引用计数一直未能降为0，所以一直不能释放空间
```

- 使用`weak_ptr`解决上述问题：将其中一个类的指针改为weak即可，下面该的B的

```cpp
class B {
public:
    std::weak_ptr<A> ptrA;

    B() {
        std::cout << "B构造" << std::endl;
    }
    ~B() {
        std::cout << "B析构" << std::endl;
    }
};
```

- 使用`weak_ptr`访问指向的对象
  - lock()：尝试把一个`weak_ptr`转换为`shared_ptr`，并返回shared_ptr<>类型
  - lock()返回的是一个**新的shared_ptr**，其会增加引用计数

```cpp
std::shared_ptr<int> sp = std::make_shared<int>(100);
std::weak_ptr<int> wp = sp;

if (auto locked = wp.lock()) {
    std::cout << "value = " << *locked << std::endl;
}
else {
    std::cout << "对象不存在" << std::endl;
}
```

#### ⑥小作业：实现SimpleUniqueptr

> ```cpp
> template<typename T>
> 
> class SimpleUniquePtr {
> public:
>     // 默认构造
>     SimpleUniquePtr() : ptr(nullptr){}
> 
>     // 参数化构造（指针构造）
>     explicit SimpleUniquePtr (T* ptr) : ptr(ptr) {}
> 
>     // 删除拷贝构造 - 禁止通过拷贝构造创建同一对象的另一个unique_ptr（唯一性）
>     SimpleUniquePtr(const SimpleUniquePtr&) = delete;
> 
>     // 删除拷贝赋值
>     SimpleUniquePtr& operator=(const SimpleUniquePtr&) = delete;
> 
>     // 移动构造
>     SimpleUniquePtr(SimpleUniquePtr&& other) noexcept : ptr(other) {
>         other.ptr = nullptr;
>     }
>     // 移动赋值
>     SimpleUniquePtr& operator=(SimpleUniquePtr&& other) noexcept {
>         if (this != other) {
>             delete this->ptr;
>             this->ptr = other.ptr;
>             other.ptr = nullptr;
>         }
>         return *this;
>     }
>     // 重载*
>     T& operator*() const {
>         return *ptr;
>     }
>     // 重载->
>     T* operator->() const {
>         return ptr;
>     }
>     // reset
>     void reset(T* p = nullptr) {
>         delete ptr;
>         ptr = p;
>     }
>     // 析构
>     ~SimpleUniquePtr() {
>         delete ptr;
>     }
> 
> private:
>     T* ptr; // 指向管理的对象
> };
> ```

#### ⑦指针避免容器与继承的切片问题

- 切片问题原因：当**按值存储**或**按值赋值**一个派生类对象给基类对象，编译器**只会调用基类的拷贝构造（因为要传值）**，因此**只能拷贝基类的部分**

```cpp
class Base {
public:
    virtual void show() const {std::cout << "Base show" << std::endl;}
    virtual ~Base() {}
};

class Sub : public Base {
public:
    void show() const override {std::cout << "Sub show" << std::endl;}
    ~Sub() {}
};

int main() {
    std::vector<Base> vec;
    Sub s;
    vec.push_back(s);
    vec[0].show(); // Base show，父类show丢失

    return 0;
}
```

- 解决：使用指针或智能指针存储

```cpp
int main() {
    std::vector<std::unique_ptr<Base>> vec;
    auto ps = std::make_unique<Sub>();
    vec.push_back(std::move(ps)); // 注意这里用了move，因为unique_ptr不可被拷贝
    vec[0]->show(); // Sub show

    return 0
}
```

### 8.std::function 与 std::bind

- 目前已知的C++中的可调用对象：普通函数、仿函数、lambda表达式等
- `std::function`可以封装任何可调用对象，可以**通过统一的接口去调用不同类型的可调用对象**
- 需包含头文件`<functional>`
- 很到位的例子：

```cpp
// 普通函数
int add (int x, int y) {
    return x + y;
}

// 仿函数
struct Sub {
    int operator() (int x,int y) {
        return x - y;
    }
};

// lambda
auto f = [] () {std::cout << "hello world!" << std::endl;};

int main() {
    std::function<int(int,int)> func1 = add;

    Sub sub;
    std::function<int(int,int)> func2 = sub;

    std::function<void()> func3 = f;

    std::cout << func1(1,1) << std::endl; // 2
    std::cout << func2(1,2) << std::endl; // -1
    func3(); // hello world!
}
```

