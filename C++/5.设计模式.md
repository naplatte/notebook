### 遇到啥学啥之

#### 0.设计原则

- 开闭原则：对扩展开放，对修改关闭；当系统需要加新功能或修改行为时，不应去修改已有的类（避免新bug），而是通过**继承、接口、多态、组合等手段**来实现扩展

#### 1.单例

##### 1.1 是什么

- 保证一个类只有一个实例，并提供一个访问该实例的全局节点（static）

##### 1.2 怎么构造单例

- 几乎所有的单例都包含下面两个步骤
  - 将**默认构造函数设为私有**，防止其他对象对单例类执行构造
  - 新建一个静态构建方法==（注意返回值为引用类型，而非值类型）==作为“受控的构造函数”，它在第一次调用时创建唯一实例，后续再调用时，返回同一个实例（即一个缓存对象）

##### 1.3 代码

```cpp
class A {
public:
    static A& getInstance(); // 对外提供一个统一的全局的访问接口，注意返回值为引用类型

private:
    A(); // 默认构造设为私有
    A(const A& rhs) = delete; // 禁止拷贝
    A& operator=(const A& rhs) = delete; // 禁止赋值
};

A& A :: getInstance() {
    static A a; 
    return a;
}

int main() {
    A& a1 = A::getInstance();
    A& a2 = A::getInstance();
    A& a3 = A::getInstance(); // a1 a2 a3实际都是同一个对象
}
```

#### 2.工厂

##### 2.1 简单工厂

- 核心：不在外部new对象，而是通过一个**工厂类**集中创建

- 🌰：一个基类Animal，两个子类

  ```cpp
  class Animal {
  public:
      virtual void speak() = 0;
      virtual ~Animal() {}
  };
  
  class Dog : public Animal {
  public:
      void speak() override { cout << "汪汪！" << endl; }
  };
  
  class Cat : public Animal {
  public:
      void speak() override { cout << "喵喵！" << endl; }
  };
  
  ```

  - 写一个工厂类，直观理解：**在工厂类里统一管理创建实例**

  ```cpp
  class SimpleFactory {
  public:
      static Animal* createAnimal(const string& type) {
          if (type == "dog") return new Dog();
          else if (type == "cat") return new Cat();
          else return nullptr;
      }
  };
  // 使用工厂类创建实例
      Animal* a1 = SimpleFactory::createAnimal("dog");
      Animal* a2 = SimpleFactory::createAnimal("cat");
  ```

- 好处：统一由工厂创建对象，管理方便

- 缺点：违反**开闭原则**，每新增一个类，就需要更改工厂类代码

##### 2.2 工厂方法

> 为了解决每新增一个类就要改工厂的问题

- 核心：**让每个产品提供自己的工厂类，而所有产品的工厂类都是总工厂类的子类**
- 以上述动物类的例子，即每类动物都提供自己的工厂类，而所有工厂类都是总工厂类的子类

```cpp
// 总工厂类
class Factory {
public:
    virtual Animal* createAnimal() = 0;
    virtual ~Factory() {}
};
```

```cpp
// 不同动物的工厂
class DogFactory : public Factory {
public:
    Animal* createAnimal() override {
        return new Dog();
    }
};

class CatFactory : public Factory {
public:
    Animal* createAnimal() override {
        return new Cat();
    }
};
```

- 这样如果之后新加入动物类，则只需提供对应类别的工厂类接口即可

##### 2.3 抽象工厂

用到再看